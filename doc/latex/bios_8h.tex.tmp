\hypertarget{bios_8h}{}\doxysection{bios.\+h File Reference}
\label{bios_8h}\index{bios.h@{bios.h}}


The Virtual Machine API.  


{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include $<$ucontext.\+h$>$}\newline
Include dependency graph for bios.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structvm__config}{vm\+\_\+config}}
\begin{DoxyCompactList}\small\item\em Virtual machine configuration. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{bios_8h_a009855593b59738d24dbfc236edb3b14}{MAX\+\_\+\+CORES}}~32
\begin{DoxyCompactList}\small\item\em Maximum number of cores for a virtual machine. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{bios_8h_a4e7d162c7c35103b42768ff4a5c73905}{MAX\+\_\+\+TERMINALS}}~4
\begin{DoxyCompactList}\small\item\em Maximum number of terminals for a virtual machine. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef void \mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}}()
\begin{DoxyCompactList}\small\item\em The signature type of interrupt handlers. \end{DoxyCompactList}\item 
typedef int \mbox{\hyperlink{bios_8h_a5d486213aa4f744f497959af6917e2a0}{sig\+\_\+atomic\+\_\+t}}
\item 
typedef unsigned int \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}
\begin{DoxyCompactList}\small\item\em Helper declaration. \end{DoxyCompactList}\item 
typedef uint64\+\_\+t \mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}}
\begin{DoxyCompactList}\small\item\em A type for time intervals measured in microseconds. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{bios_8h_adae0801dc227f7fab2d61d0b7c9e9643}\label{bios_8h_adae0801dc227f7fab2d61d0b7c9e9643}} 
typedef enum \mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}} {\bfseries Interrupt}
\begin{DoxyCompactList}\small\item\em The interrupts supported by the CPU. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{structvm__config}{vm\+\_\+config}} \mbox{\hyperlink{bios_8h_a78f20592af397bf72970300f0e8dba4d}{vm\+\_\+config}}
\begin{DoxyCompactList}\small\item\em Virtual machine configuration. \end{DoxyCompactList}\item 
typedef ucontext\+\_\+t \mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}}
\begin{DoxyCompactList}\small\item\em A type for saving CPU context into. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}} \{ \newline
\mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaaab4019255561cb4b48789d55c079e1709}{ICI}}
, \mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaaac4212312865bd8ac6810b9651d9e80df}{ALARM}}
, \mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaaa2e06ea796d072595be1770c601e78206}{SERIAL\+\_\+\+RX\+\_\+\+READY}}
, \mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaaad168539d997c69c61da9c1f5f3187878}{SERIAL\+\_\+\+TX\+\_\+\+READY}}
, \newline
{\bfseries maximum\+\_\+interrupt\+\_\+no}
 \}
\begin{DoxyCompactList}\small\item\em The interrupts supported by the CPU. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{bios_8h_af72e3b1217697a5ae7ecf22e1d1d078a}{vm\+\_\+config\+\_\+terminals}} (\mbox{\hyperlink{structvm__config}{vm\+\_\+config}} $\ast$vmc, \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} serialno, int nowait)
\begin{DoxyCompactList}\small\item\em Initialize a VM configuration\textquotesingle{}s serial ports using the terminal emulators. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a0642848175ea5155275f9a298dd2475e}{vm\+\_\+configure}} (\mbox{\hyperlink{structvm__config}{vm\+\_\+config}} $\ast$vmc, \mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}} bootfunc, \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} cores, \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} serialno)
\begin{DoxyCompactList}\small\item\em Initialize a VM configuration with passed parameters. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a37f8796b7357cdfedc482c0b05c6a115}{vm\+\_\+run}} (\mbox{\hyperlink{structvm__config}{vm\+\_\+config}} $\ast$vmc)
\begin{DoxyCompactList}\small\item\em Boot a Virtual Machine with the given configuration. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a3474751482bc2a9a40597f66fe35f630}{vm\+\_\+boot}} (\mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}} bootfunc, \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} cores, \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} serialno)
\begin{DoxyCompactList}\small\item\em Boot a CPU with the given number of cores and boot function. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{bios_8h_aa02a29e5c8a1f4d68413eea0aaa09fba}\label{bios_8h_aa02a29e5c8a1f4d68413eea0aaa09fba}} 
\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} {\bfseries cpu\+\_\+cores} ()
\begin{DoxyCompactList}\small\item\em Returns the number of cores. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_ab8f96f6027a2276735b4a221a56ed786}{cpu\+\_\+core\+\_\+barrier\+\_\+sync}} ()
\begin{DoxyCompactList}\small\item\em Barrier synchronization for all cores. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a719b0f9f8854d21436c96931ba1caf59}{cpu\+\_\+ici}} (\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} core)
\begin{DoxyCompactList}\small\item\em Raise an ICI interrupt to the given core. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a0cf5c5e80f04d98362346e6ec770022d}{cpu\+\_\+interrupt\+\_\+handler}} (\mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}} interrupt, \mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}} handler)
\begin{DoxyCompactList}\small\item\em Define an interrupt handler for this core. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{bios_8h_afec1cd080e34866f6497b18f1bac8e8f}{cpu\+\_\+disable\+\_\+interrupts}} ()
\begin{DoxyCompactList}\small\item\em Disable interrupts for this core. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{bios_8h_af61d7c032b12e989a7005d830f71054f}{cpu\+\_\+interrupts\+\_\+enabled}} ()
\begin{DoxyCompactList}\small\item\em Get the current interrupt status for this core. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a10055a90cf57a2a22fa9193922f9f2a8}{cpu\+\_\+enable\+\_\+interrupts}} ()
\begin{DoxyCompactList}\small\item\em Enable interrupts for this core. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a3e2c9a3aea40c8eeaa723ee35caace06}{cpu\+\_\+core\+\_\+halt}} ()
\begin{DoxyCompactList}\small\item\em Halt the core until an interrupt arrives. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a9191a31f24c07b8282a3c8edbba24ee0}{cpu\+\_\+core\+\_\+restart}} (\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} c)
\begin{DoxyCompactList}\small\item\em Restart the given core. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a7eeccd43040cc43ac977f649d639a3e9}{cpu\+\_\+core\+\_\+restart\+\_\+one}} ()
\begin{DoxyCompactList}\small\item\em Restart some halted core. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_aa82b1a876663da26cbf511bcfb06404d}{cpu\+\_\+core\+\_\+restart\+\_\+all}} ()
\begin{DoxyCompactList}\small\item\em Signal all halted cores to restart. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a825ac4a4bcf2ef8d3c9bb48d5434c161}{cpu\+\_\+initialize\+\_\+context}} (\mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}} $\ast$ctx, void $\ast$ss\+\_\+sp, size\+\_\+t ss\+\_\+size, void($\ast$func)())
\begin{DoxyCompactList}\small\item\em Initialize a CPU context for a new thread. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a78a3870d56e6867224909cf226c2e90a}{cpu\+\_\+swap\+\_\+context}} (\mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}} $\ast$oldctx, \mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}} $\ast$newctx)
\begin{DoxyCompactList}\small\item\em Switch the CPU context. \end{DoxyCompactList}\item 
\mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} \mbox{\hyperlink{bios_8h_a01f7a35679bdda42fff3da6ae6e5664b}{bios\+\_\+set\+\_\+timer}} (\mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} usec)
\begin{DoxyCompactList}\small\item\em Reset the core timer to the specified interval. \end{DoxyCompactList}\item 
\mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} \mbox{\hyperlink{bios_8h_a27768c037d72b51415b836bd93196df2}{bios\+\_\+cancel\+\_\+timer}} ()
\begin{DoxyCompactList}\small\item\em Cancel the current activated timer, if any. \end{DoxyCompactList}\item 
\mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} \mbox{\hyperlink{bios_8h_a78addcd72c31fb32d46cc51fe01a86b4}{bios\+\_\+clock}} ()
\begin{DoxyCompactList}\small\item\em Get the current time from the hardware clock. \end{DoxyCompactList}\item 
\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} \mbox{\hyperlink{bios_8h_af69405820033d3f2e8033af258f47ea2}{bios\+\_\+serial\+\_\+ports}} ()
\begin{DoxyCompactList}\small\item\em Return the number of serial ports/terminals. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{bios_8h_a3d9df4f1db5a1d99720f327668726e2b}{bios\+\_\+serial\+\_\+interrupt\+\_\+core}} (\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} serial, \mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}} intno, \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} core)
\begin{DoxyCompactList}\small\item\em Assign a core to interrupts from a specific serial device. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{bios_8h_a04ebe8b1d424c0ef473db751f7b79fbb}{bios\+\_\+read\+\_\+serial}} (\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} serial, char $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Read a byte from a serial port. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{bios_8h_a97bde2ebd5f9d86c0085aacaa5e5d287}{bios\+\_\+write\+\_\+serial}} (\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} serial, char value)
\begin{DoxyCompactList}\small\item\em Write a byte to a serial port. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{bios_8h_abac58ced7d51f54f2318b326bc991933}\label{bios_8h_abac58ced7d51f54f2318b326bc991933}} 
\+\_\+\+Thread\+\_\+local \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} {\bfseries cpu\+\_\+core\+\_\+id}
\begin{DoxyCompactList}\small\item\em Contains the id of the current core. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The Virtual Machine API. 

This file contains the API for a virtual machine (simulated computer) which we will refer to as VM. This VM is used to implement tinyos3 on.

The VM has a multicore CPU and peripherals.

A simulation starts by calling function {\ttfamily vm\+\_\+boot}. The description of the VM (currently, the number of simulated cores and the number of terminal devices), and also the initial function executed by each core at boot time, are given as arguments.

The VM (virtual) hardware is controlled by a BIOS (Basic I/O System) through the BIOS API. We now describe the concepts of the BIOS in detail.\hypertarget{bios_8h_autotoc_md0}{}\doxysubsubsection{CPU}\label{bios_8h_autotoc_md0}
A CPU has 1 or more cores. Each core executes independently of each other. Variable cpu\+\_\+core\+\_\+id contains the id number of the current core.\hypertarget{bios_8h_autotoc_md1}{}\doxysubsubsection{Interrupts}\label{bios_8h_autotoc_md1}
Each CPU core has its own interrupt vector---it can set its own interrupt handlers, independently of other cores. Setting an interrupt handler to {\ttfamily NULL} (the default), ignores the interrupt for this core.


\begin{DoxyItemize}
\item When an interrupt handler executes, interrupts are initially disabled.
\item Interrupts can also be enabled and disabled programmatically.
\item If an interrupt is raised while interrupts are disabled, it will be marked as raised and the interrupt handler (if non-\/\+NULL) will be called as soon as interrupts are re-\/enabled.
\item The {\bfseries{ICI}} (Inter-\/\+Core Interrupt) interrupt can be sent from one core to another (or to itself!).
\end{DoxyItemize}\hypertarget{bios_8h_autotoc_md2}{}\doxysubsubsection{Peripherals}\label{bios_8h_autotoc_md2}
The peripherals are managed via the \textquotesingle{}bios\+\_\+...\textquotesingle{} functions.

There are two types of simulated peripherals\+: {\itshape timers} and {\itshape serial ports} (connected to terminals). Each type of peripheral is documented below.\hypertarget{bios_8h_autotoc_md3}{}\doxysubsubsection{Timers}\label{bios_8h_autotoc_md3}
Each simulated core has its own timer. A timer can be activated by initializing it with some time interval. When the timer expires, the ALARM interrupt is raised for the core.\hypertarget{bios_8h_autotoc_md4}{}\doxysubsubsection{Serial ports}\label{bios_8h_autotoc_md4}
The virtual machine has a number of serial ports connected to terminals.

Each serial port/terminal can support reading and writing of single bytes. The reads return keyboard input, whereas the writes send characters to display on the screen.

Terminals are numbered from 0, up to {\ttfamily MAX\+\_\+\+TERMINALS-\/1}.

Implementation-\/wise, for each terminal/serial port, two Unix named pipes must exist in the current directory\+: one named con $ N $ and one named kbd $ N $, where $ N $ is the number of the serial port. For example, if the computer has 2 serial ports, the following named pipes must be defined in the current directory at runtime\+: con0 kbd0 con1 kbd1

Also, program \textquotesingle{}terminal\textquotesingle{} must be executed twice (in two different windows)\+:

./terminal 0

./terminal 1

Data can be read from a serial port, one byte at a time. A read may fail if the device is not-\/ready to perform the operation. On a device which is ready, the read will succeed. When a non-\/ready device becomes ready, a {\ttfamily SERIAL\+\_\+\+RX\+\_\+\+READY} interrupt is raised.

Data can be written to a serial port, one byte at a time. A write may fail if the device is not-\/ready to perform the operation. On a device which is ready, the write will succeed. When a non-\/ready device becomes ready, a {\ttfamily SERIAL\+\_\+\+TX\+\_\+\+READY} interrupt is raised.

Also, each interrupt is sent if the serial device timeouts (is inactive for about 300 msec). 

Definition in file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.



\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{bios_8h_a009855593b59738d24dbfc236edb3b14}\label{bios_8h_a009855593b59738d24dbfc236edb3b14}} 
\index{bios.h@{bios.h}!MAX\_CORES@{MAX\_CORES}}
\index{MAX\_CORES@{MAX\_CORES}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{MAX\_CORES}{MAX\_CORES}}
{\footnotesize\ttfamily \#define MAX\+\_\+\+CORES~32}



Maximum number of cores for a virtual machine. 



Definition at line \mbox{\hyperlink{bios_8h_source_l00132}{132}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.

\mbox{\Hypertarget{bios_8h_a4e7d162c7c35103b42768ff4a5c73905}\label{bios_8h_a4e7d162c7c35103b42768ff4a5c73905}} 
\index{bios.h@{bios.h}!MAX\_TERMINALS@{MAX\_TERMINALS}}
\index{MAX\_TERMINALS@{MAX\_TERMINALS}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{MAX\_TERMINALS}{MAX\_TERMINALS}}
{\footnotesize\ttfamily \#define MAX\+\_\+\+TERMINALS~4}



Maximum number of terminals for a virtual machine. 



Definition at line \mbox{\hyperlink{bios_8h_source_l00135}{135}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.



\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}\label{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}} 
\index{bios.h@{bios.h}!cpu\_context\_t@{cpu\_context\_t}}
\index{cpu\_context\_t@{cpu\_context\_t}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_context\_t}{cpu\_context\_t}}
{\footnotesize\ttfamily typedef ucontext\+\_\+t \mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}}}



A type for saving CPU context into. 



Definition at line \mbox{\hyperlink{bios_8h_source_l00411}{411}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.

\mbox{\Hypertarget{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}\label{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}} 
\index{bios.h@{bios.h}!interrupt\_handler@{interrupt\_handler}}
\index{interrupt\_handler@{interrupt\_handler}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{interrupt\_handler}{interrupt\_handler}}
{\footnotesize\ttfamily typedef void interrupt\+\_\+handler()}



The signature type of interrupt handlers. 



Definition at line \mbox{\hyperlink{bios_8h_source_l00107}{107}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.

\mbox{\Hypertarget{bios_8h_a5d486213aa4f744f497959af6917e2a0}\label{bios_8h_a5d486213aa4f744f497959af6917e2a0}} 
\index{bios.h@{bios.h}!sig\_atomic\_t@{sig\_atomic\_t}}
\index{sig\_atomic\_t@{sig\_atomic\_t}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{sig\_atomic\_t}{sig\_atomic\_t}}
{\footnotesize\ttfamily typedef int sig\+\_\+atomic\+\_\+t}



Definition at line \mbox{\hyperlink{bios_8h_source_l00109}{109}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.

\mbox{\Hypertarget{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}\label{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}} 
\index{bios.h@{bios.h}!TimerDuration@{TimerDuration}}
\index{TimerDuration@{TimerDuration}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{TimerDuration}{TimerDuration}}
{\footnotesize\ttfamily typedef uint64\+\_\+t \mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}}}



A type for time intervals measured in microseconds. 



Definition at line \mbox{\hyperlink{bios_8h_source_l00115}{115}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.

\mbox{\Hypertarget{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}\label{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}} 
\index{bios.h@{bios.h}!uint@{uint}}
\index{uint@{uint}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{uint}{uint}}
{\footnotesize\ttfamily typedef unsigned int \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}



Helper declaration. 



Definition at line \mbox{\hyperlink{bios_8h_source_l00112}{112}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.

\mbox{\Hypertarget{bios_8h_a78f20592af397bf72970300f0e8dba4d}\label{bios_8h_a78f20592af397bf72970300f0e8dba4d}} 
\index{bios.h@{bios.h}!vm\_config@{vm\_config}}
\index{vm\_config@{vm\_config}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{vm\_config}{vm\_config}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{structvm__config}{vm\+\_\+config}} \mbox{\hyperlink{structvm__config}{vm\+\_\+config}}}



Virtual machine configuration. 

The configuration of the virtual machine consists of the following information\+:


\begin{DoxyItemize}
\item The boot function to execute on each core of the simulated machine, stored in {\ttfamily bootfunc}.
\item The number of CPU cores of this VM, stored in {\ttfamily cores} 
\item The number of serial devices of this VM, stored in {\ttfamily serialno} 
\item For each serial device, two file descriptors must be provided\+: the keyboard ({\ttfamily serial\+\_\+in}) file descriptor will be read from and the console ({\ttfamily serial\+\_\+out}) file descriptor will be written to. These file descriptors should correspond to some pipe-\/like Linux stream (e.\+g., pipe, FIFO or socket). 
\end{DoxyItemize}

\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}\label{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}} 
\index{bios.h@{bios.h}!Interrupt@{Interrupt}}
\index{Interrupt@{Interrupt}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{Interrupt}{Interrupt}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}}}



The interrupts supported by the CPU. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{ICI@{ICI}!bios.h@{bios.h}}\index{bios.h@{bios.h}!ICI@{ICI}}}\mbox{\Hypertarget{bios_8h_a137af7bce5ff764f5c0aa4550086deaaab4019255561cb4b48789d55c079e1709}\label{bios_8h_a137af7bce5ff764f5c0aa4550086deaaab4019255561cb4b48789d55c079e1709}} 
ICI&Raised by some core, via \mbox{\hyperlink{bios_8h_a719b0f9f8854d21436c96931ba1caf59}{cpu\+\_\+ici()}} \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ALARM@{ALARM}!bios.h@{bios.h}}\index{bios.h@{bios.h}!ALARM@{ALARM}}}\mbox{\Hypertarget{bios_8h_a137af7bce5ff764f5c0aa4550086deaaac4212312865bd8ac6810b9651d9e80df}\label{bios_8h_a137af7bce5ff764f5c0aa4550086deaaac4212312865bd8ac6810b9651d9e80df}} 
ALARM&Raised when the core\textquotesingle{}s timer expires. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SERIAL\_RX\_READY@{SERIAL\_RX\_READY}!bios.h@{bios.h}}\index{bios.h@{bios.h}!SERIAL\_RX\_READY@{SERIAL\_RX\_READY}}}\mbox{\Hypertarget{bios_8h_a137af7bce5ff764f5c0aa4550086deaaa2e06ea796d072595be1770c601e78206}\label{bios_8h_a137af7bce5ff764f5c0aa4550086deaaa2e06ea796d072595be1770c601e78206}} 
SERIAL\+\_\+\+RX\+\_\+\+READY&Raised when data is available for reading from a serial port \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SERIAL\_TX\_READY@{SERIAL\_TX\_READY}!bios.h@{bios.h}}\index{bios.h@{bios.h}!SERIAL\_TX\_READY@{SERIAL\_TX\_READY}}}\mbox{\Hypertarget{bios_8h_a137af7bce5ff764f5c0aa4550086deaaad168539d997c69c61da9c1f5f3187878}\label{bios_8h_a137af7bce5ff764f5c0aa4550086deaaad168539d997c69c61da9c1f5f3187878}} 
SERIAL\+\_\+\+TX\+\_\+\+READY&Raised when a serial port is ready to accept data \\
\hline

\end{DoxyEnumFields}


Definition at line \mbox{\hyperlink{bios_8h_source_l00118}{118}} of file \mbox{\hyperlink{bios_8h_source}{bios.\+h}}.



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{bios_8h_a27768c037d72b51415b836bd93196df2}\label{bios_8h_a27768c037d72b51415b836bd93196df2}} 
\index{bios.h@{bios.h}!bios\_cancel\_timer@{bios\_cancel\_timer}}
\index{bios\_cancel\_timer@{bios\_cancel\_timer}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{bios\_cancel\_timer()}{bios\_cancel\_timer()}}
{\footnotesize\ttfamily \mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} bios\+\_\+cancel\+\_\+timer (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Cancel the current activated timer, if any. 

This can be called even if the timer is not already activated. This call is equivalent to bios\+\_\+set\+\_\+timer(0).

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{bios_8h_a01f7a35679bdda42fff3da6ae6e5664b}{bios\+\_\+set\+\_\+timer}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{bios_8h_a78addcd72c31fb32d46cc51fe01a86b4}\label{bios_8h_a78addcd72c31fb32d46cc51fe01a86b4}} 
\index{bios.h@{bios.h}!bios\_clock@{bios\_clock}}
\index{bios\_clock@{bios\_clock}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{bios\_clock()}{bios\_clock()}}
{\footnotesize\ttfamily \mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} bios\+\_\+clock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the current time from the hardware clock. 

This function returns a real-\/time clock value, in usec. The value of the clock is 10 times the number of seconds since the epoch.

The resolution of the clock is very low, currently around 100 msec. Therefore, it is inappropriate for any type of precise timing. \mbox{\Hypertarget{bios_8h_a04ebe8b1d424c0ef473db751f7b79fbb}\label{bios_8h_a04ebe8b1d424c0ef473db751f7b79fbb}} 
\index{bios.h@{bios.h}!bios\_read\_serial@{bios\_read\_serial}}
\index{bios\_read\_serial@{bios\_read\_serial}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{bios\_read\_serial()}{bios\_read\_serial()}}
{\footnotesize\ttfamily int bios\+\_\+read\+\_\+serial (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{serial,  }\item[{char $\ast$}]{ptr }\end{DoxyParamCaption})}



Read a byte from a serial port. 

Try to read a byte from serial port {\ttfamily serial} and store it into the location pointed by {\ttfamily ptr}. If the operation succeds, 1 is returned. If not, 0 is returned. The operation may not succeed, if the terminal connected to the serial port has not sent any data.

If this operation returns 0, a {\ttfamily SERIAL\+\_\+\+RX\+\_\+\+READY} interrupt will be raised when data is ready to be received, but the contents of {\ttfamily $\ast$ptr} will not be touched.


\begin{DoxyParams}{Parameters}
{\em serial} & the serial device to read from \\
\hline
{\em ptr} & the location in which to store the read byte \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a integer designating success (non-\/zero) or failure (zero) 
\end{DoxyReturn}
\mbox{\Hypertarget{bios_8h_a3d9df4f1db5a1d99720f327668726e2b}\label{bios_8h_a3d9df4f1db5a1d99720f327668726e2b}} 
\index{bios.h@{bios.h}!bios\_serial\_interrupt\_core@{bios\_serial\_interrupt\_core}}
\index{bios\_serial\_interrupt\_core@{bios\_serial\_interrupt\_core}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{bios\_serial\_interrupt\_core()}{bios\_serial\_interrupt\_core()}}
{\footnotesize\ttfamily void bios\+\_\+serial\+\_\+interrupt\+\_\+core (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{serial,  }\item[{\mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}}}]{intno,  }\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{core }\end{DoxyParamCaption})}



Assign a core to interrupts from a specific serial device. 

Make interrupts of type {\ttfamily intno} for serial port port {\ttfamily serial} be sent to {\ttfamily core}. By default, initially all interrupts are sent to core 0.

If any parameter has an illegal value, this call has no effect.


\begin{DoxyParams}{Parameters}
{\em serial} & the serial device whose interrupt is assigned, it must be greater of equal to {\ttfamily 0} and less than {\ttfamily \mbox{\hyperlink{bios_8h_af69405820033d3f2e8033af258f47ea2}{bios\+\_\+serial\+\_\+ports()}}}. \\
\hline
{\em intno} & the interrupt to assign (one of {\ttfamily SERIAL\+\_\+\+RX\+\_\+\+READY} and {\ttfamily SERIAL\+\_\+\+TX\+\_\+\+READY}) \\
\hline
{\em core} & the core that will handle this interrupt. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{bios_8h_af69405820033d3f2e8033af258f47ea2}\label{bios_8h_af69405820033d3f2e8033af258f47ea2}} 
\index{bios.h@{bios.h}!bios\_serial\_ports@{bios\_serial\_ports}}
\index{bios\_serial\_ports@{bios\_serial\_ports}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{bios\_serial\_ports()}{bios\_serial\_ports()}}
{\footnotesize\ttfamily \mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} bios\+\_\+serial\+\_\+ports (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Return the number of serial ports/terminals. 

This is the number specified at the initialization of the VM. \mbox{\Hypertarget{bios_8h_a01f7a35679bdda42fff3da6ae6e5664b}\label{bios_8h_a01f7a35679bdda42fff3da6ae6e5664b}} 
\index{bios.h@{bios.h}!bios\_set\_timer@{bios\_set\_timer}}
\index{bios\_set\_timer@{bios\_set\_timer}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{bios\_set\_timer()}{bios\_set\_timer()}}
{\footnotesize\ttfamily \mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} bios\+\_\+set\+\_\+timer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}}}]{usec }\end{DoxyParamCaption})}



Reset the core timer to the specified interval. 

The interval for the timer is given in microseconds, but the accuracy of the alarm is much coarser, to the order of 10 msec (that is, 10,000 microseconds). After the interval expires, the core receives an ALARM interrupt.

This function can be called even if the timer is already activated; in this case, the previous timer countdown is canceled and the timer resets to the new value.

If {\ttfamily usec} is specified as 0, any existing timer count is canceled.


\begin{DoxyParams}{Parameters}
{\em usec} & the timer countdown interval in microseconds \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the time remaining interval since the last call 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{bios_8h_a27768c037d72b51415b836bd93196df2}{bios\+\_\+cancel\+\_\+timer}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{bios_8h_a97bde2ebd5f9d86c0085aacaa5e5d287}\label{bios_8h_a97bde2ebd5f9d86c0085aacaa5e5d287}} 
\index{bios.h@{bios.h}!bios\_write\_serial@{bios\_write\_serial}}
\index{bios\_write\_serial@{bios\_write\_serial}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{bios\_write\_serial()}{bios\_write\_serial()}}
{\footnotesize\ttfamily int bios\+\_\+write\+\_\+serial (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{serial,  }\item[{char}]{value }\end{DoxyParamCaption})}



Write a byte to a serial port. 

Try to write byte {\ttfamily value} to serial port {\ttfamily serial}. If the operation succeds, 1 is returned. If not, 0 is returned.

If this operation returns 0, a {\ttfamily SERIAL\+\_\+\+TX\+\_\+\+READY} interrupt will be raised when the device is ready to accept data.


\begin{DoxyParams}{Parameters}
{\em serial} & the serial device to write to \\
\hline
{\em value} & the value to send to the serial device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a integer designating success (non-\/zero) or failure (zero) 
\end{DoxyReturn}
\mbox{\Hypertarget{bios_8h_ab8f96f6027a2276735b4a221a56ed786}\label{bios_8h_ab8f96f6027a2276735b4a221a56ed786}} 
\index{bios.h@{bios.h}!cpu\_core\_barrier\_sync@{cpu\_core\_barrier\_sync}}
\index{cpu\_core\_barrier\_sync@{cpu\_core\_barrier\_sync}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_core\_barrier\_sync()}{cpu\_core\_barrier\_sync()}}
{\footnotesize\ttfamily void cpu\+\_\+core\+\_\+barrier\+\_\+sync (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Barrier synchronization for all cores. 

Each core calling this function stops, until all cores have called it. Then, all cores proceed.

This is mostly useful when the machine boots the operating system, or at shutdown. \mbox{\Hypertarget{bios_8h_a3e2c9a3aea40c8eeaa723ee35caace06}\label{bios_8h_a3e2c9a3aea40c8eeaa723ee35caace06}} 
\index{bios.h@{bios.h}!cpu\_core\_halt@{cpu\_core\_halt}}
\index{cpu\_core\_halt@{cpu\_core\_halt}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_core\_halt()}{cpu\_core\_halt()}}
{\footnotesize\ttfamily void cpu\+\_\+core\+\_\+halt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Halt the core until an interrupt arrives. 

This function will block the core on which it is called, until an interrupt arrives for the core.

This function is useful when a core becomes idle. An idle core does not consume simulation resources (in particular CPU time). \mbox{\Hypertarget{bios_8h_a9191a31f24c07b8282a3c8edbba24ee0}\label{bios_8h_a9191a31f24c07b8282a3c8edbba24ee0}} 
\index{bios.h@{bios.h}!cpu\_core\_restart@{cpu\_core\_restart}}
\index{cpu\_core\_restart@{cpu\_core\_restart}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_core\_restart()}{cpu\_core\_restart()}}
{\footnotesize\ttfamily void cpu\+\_\+core\+\_\+restart (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{c }\end{DoxyParamCaption})}



Restart the given core. 

This call will restart the given core, if it was halted. 
\begin{DoxyParams}{Parameters}
{\em c} & the core to restart \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{bios_8h_aa82b1a876663da26cbf511bcfb06404d}\label{bios_8h_aa82b1a876663da26cbf511bcfb06404d}} 
\index{bios.h@{bios.h}!cpu\_core\_restart\_all@{cpu\_core\_restart\_all}}
\index{cpu\_core\_restart\_all@{cpu\_core\_restart\_all}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_core\_restart\_all()}{cpu\_core\_restart\_all()}}
{\footnotesize\ttfamily void cpu\+\_\+core\+\_\+restart\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Signal all halted cores to restart. 

When this function is called, all halted cores will be restarted. \mbox{\Hypertarget{bios_8h_a7eeccd43040cc43ac977f649d639a3e9}\label{bios_8h_a7eeccd43040cc43ac977f649d639a3e9}} 
\index{bios.h@{bios.h}!cpu\_core\_restart\_one@{cpu\_core\_restart\_one}}
\index{cpu\_core\_restart\_one@{cpu\_core\_restart\_one}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_core\_restart\_one()}{cpu\_core\_restart\_one()}}
{\footnotesize\ttfamily void cpu\+\_\+core\+\_\+restart\+\_\+one (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Restart some halted core. 

This call will restart some halted core, if at least one exists. \mbox{\Hypertarget{bios_8h_afec1cd080e34866f6497b18f1bac8e8f}\label{bios_8h_afec1cd080e34866f6497b18f1bac8e8f}} 
\index{bios.h@{bios.h}!cpu\_disable\_interrupts@{cpu\_disable\_interrupts}}
\index{cpu\_disable\_interrupts@{cpu\_disable\_interrupts}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_disable\_interrupts()}{cpu\_disable\_interrupts()}}
{\footnotesize\ttfamily int cpu\+\_\+disable\+\_\+interrupts (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Disable interrupts for this core. 

If an interrupt arrives while interrupts are disabled, it will be marked as {\itshape pending} and will be raised when interrupts are re-\/enabled.

\begin{DoxyReturn}{Returns}
1 if interrupts were enabled before the call, else 0. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{bios_8h_a10055a90cf57a2a22fa9193922f9f2a8}{cpu\+\_\+enable\+\_\+interrupts}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{bios_8h_a10055a90cf57a2a22fa9193922f9f2a8}\label{bios_8h_a10055a90cf57a2a22fa9193922f9f2a8}} 
\index{bios.h@{bios.h}!cpu\_enable\_interrupts@{cpu\_enable\_interrupts}}
\index{cpu\_enable\_interrupts@{cpu\_enable\_interrupts}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_enable\_interrupts()}{cpu\_enable\_interrupts()}}
{\footnotesize\ttfamily void cpu\+\_\+enable\+\_\+interrupts (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Enable interrupts for this core. 

If an interrupt is pending, i.\+e., it arrived while interrupts were disabled, it will be raised as soon as this call is made.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{bios_8h_afec1cd080e34866f6497b18f1bac8e8f}{cpu\+\_\+disable\+\_\+interrupts}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{bios_8h_a719b0f9f8854d21436c96931ba1caf59}\label{bios_8h_a719b0f9f8854d21436c96931ba1caf59}} 
\index{bios.h@{bios.h}!cpu\_ici@{cpu\_ici}}
\index{cpu\_ici@{cpu\_ici}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_ici()}{cpu\_ici()}}
{\footnotesize\ttfamily void cpu\+\_\+ici (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{core }\end{DoxyParamCaption})}



Raise an ICI interrupt to the given core. 

This is a simple way that one core may interrupt another. \mbox{\Hypertarget{bios_8h_a825ac4a4bcf2ef8d3c9bb48d5434c161}\label{bios_8h_a825ac4a4bcf2ef8d3c9bb48d5434c161}} 
\index{bios.h@{bios.h}!cpu\_initialize\_context@{cpu\_initialize\_context}}
\index{cpu\_initialize\_context@{cpu\_initialize\_context}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_initialize\_context()}{cpu\_initialize\_context()}}
{\footnotesize\ttfamily void cpu\+\_\+initialize\+\_\+context (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}} $\ast$}]{ctx,  }\item[{void $\ast$}]{ss\+\_\+sp,  }\item[{size\+\_\+t}]{ss\+\_\+size,  }\item[{void($\ast$)()}]{func }\end{DoxyParamCaption})}



Initialize a CPU context for a new thread. 

To initialize the context, a stack segment of adequate size must be provided.


\begin{DoxyParams}{Parameters}
{\em ctx} & the context object to initialize \\
\hline
{\em ss\+\_\+sp} & the pointer to the beginning of the stack segment \\
\hline
{\em ss\+\_\+size} & the size of the stack segment \\
\hline
{\em func} & the function to execute in the new context \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{bios_8h_a0cf5c5e80f04d98362346e6ec770022d}\label{bios_8h_a0cf5c5e80f04d98362346e6ec770022d}} 
\index{bios.h@{bios.h}!cpu\_interrupt\_handler@{cpu\_interrupt\_handler}}
\index{cpu\_interrupt\_handler@{cpu\_interrupt\_handler}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_interrupt\_handler()}{cpu\_interrupt\_handler()}}
{\footnotesize\ttfamily void cpu\+\_\+interrupt\+\_\+handler (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}}}]{interrupt,  }\item[{\mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}}}]{handler }\end{DoxyParamCaption})}



Define an interrupt handler for this core. 

This function set the interrupt handler of the calling core, for the given interrupt. If {\ttfamily handler} is NULL, then the interrupt will be ignored by this core.


\begin{DoxyParams}{Parameters}
{\em interrupt} & the interrupt to set the handler for \\
\hline
{\em handler} & the handler function to call\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}} 

\mbox{\hyperlink{bios_8h_a137af7bce5ff764f5c0aa4550086deaa}{Interrupt}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{bios_8h_af61d7c032b12e989a7005d830f71054f}\label{bios_8h_af61d7c032b12e989a7005d830f71054f}} 
\index{bios.h@{bios.h}!cpu\_interrupts\_enabled@{cpu\_interrupts\_enabled}}
\index{cpu\_interrupts\_enabled@{cpu\_interrupts\_enabled}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_interrupts\_enabled()}{cpu\_interrupts\_enabled()}}
{\footnotesize\ttfamily int cpu\+\_\+interrupts\+\_\+enabled (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the current interrupt status for this core. 

\begin{DoxyReturn}{Returns}
1 if interrupts are enabled, else 0 
\end{DoxyReturn}
\mbox{\Hypertarget{bios_8h_a78a3870d56e6867224909cf226c2e90a}\label{bios_8h_a78a3870d56e6867224909cf226c2e90a}} 
\index{bios.h@{bios.h}!cpu\_swap\_context@{cpu\_swap\_context}}
\index{cpu\_swap\_context@{cpu\_swap\_context}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{cpu\_swap\_context()}{cpu\_swap\_context()}}
{\footnotesize\ttfamily void cpu\+\_\+swap\+\_\+context (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}} $\ast$}]{oldctx,  }\item[{\mbox{\hyperlink{bios_8h_a6067c1395a75fc3e17f1ea6353065b54}{cpu\+\_\+context\+\_\+t}} $\ast$}]{newctx }\end{DoxyParamCaption})}



Switch the CPU context. 

Save the current context into {\ttfamily oldctx} and load the contents of {\ttfamily newctx} into the CPU.


\begin{DoxyParams}{Parameters}
{\em oldctx} & pointer to the storage for the old context \\
\hline
{\em newctx} & pointer to the new context to be loaded \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{bios_8h_a3474751482bc2a9a40597f66fe35f630}\label{bios_8h_a3474751482bc2a9a40597f66fe35f630}} 
\index{bios.h@{bios.h}!vm\_boot@{vm\_boot}}
\index{vm\_boot@{vm\_boot}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{vm\_boot()}{vm\_boot()}}
{\footnotesize\ttfamily void vm\+\_\+boot (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}}}]{bootfunc,  }\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{cores,  }\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{serialno }\end{DoxyParamCaption})}



Boot a CPU with the given number of cores and boot function. 

This function sets up a number of simulated cores, each starting to execute function bootfunc.

The number of cores must be between 1 and MAX\+\_\+\+CORES.

Also, this function initializes the simulated peripherals (timers and terminals).

The simulation ends (and this function returns) when (and if) all cores return from bootfunc, in which case the VM shuts down.


\begin{DoxyParams}{Parameters}
{\em bootfunc} & The function that each simulated core will execute at boot time. When all cores return from this function, the virtual machine shuts down. \\
\hline
{\em cores} & The number of cores simulated by the virtual machine \\
\hline
{\em serialno} & the number of serial ports connected to terminals that the computer will support. The terminals can be accessed via named pipes (aka FIFOs), which must already exist. See the serial API below for more details. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{bios_8h_af72e3b1217697a5ae7ecf22e1d1d078a}\label{bios_8h_af72e3b1217697a5ae7ecf22e1d1d078a}} 
\index{bios.h@{bios.h}!vm\_config\_terminals@{vm\_config\_terminals}}
\index{vm\_config\_terminals@{vm\_config\_terminals}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{vm\_config\_terminals()}{vm\_config\_terminals()}}
{\footnotesize\ttfamily int vm\+\_\+config\+\_\+terminals (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structvm__config}{vm\+\_\+config}} $\ast$}]{vmc,  }\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{serialno,  }\item[{int}]{nowait }\end{DoxyParamCaption})}



Initialize a VM configuration\textquotesingle{}s serial ports using the terminal emulators. 

Set a VM configuration\textquotesingle{}s serial ports by opening the named pipes to connect to the terminal emulator program provided in the distribution of {\ttfamily Tiny\+OS}.

If {\ttfamily nowait} is non-\/zero, this function will fail and return -\/1, unless the terminal emulators are already running. If {\ttfamily nowait} is zero, this function will block until the required terminal emulators are executed.

In the case of failure, no serial ports will be opened


\begin{DoxyParams}{Parameters}
{\em vmc} & the configuration to initialize \\
\hline
{\em serialno} & the number of serial devices to prepare \\
\hline
{\em nowait} & flag that this function should not block \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
\mbox{\Hypertarget{bios_8h_a0642848175ea5155275f9a298dd2475e}\label{bios_8h_a0642848175ea5155275f9a298dd2475e}} 
\index{bios.h@{bios.h}!vm\_configure@{vm\_configure}}
\index{vm\_configure@{vm\_configure}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{vm\_configure()}{vm\_configure()}}
{\footnotesize\ttfamily void vm\+\_\+configure (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structvm__config}{vm\+\_\+config}} $\ast$}]{vmc,  }\item[{\mbox{\hyperlink{bios_8h_a11aeb47c6c66d331acd12556d0d4aedc}{interrupt\+\_\+handler}}}]{bootfunc,  }\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{cores,  }\item[{\mbox{\hyperlink{bios_8h_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{serialno }\end{DoxyParamCaption})}



Initialize a VM configuration with passed parameters. 

Prepare a VM configuration with the given parameters. This is a convenience function to initialize the VM configuration with serial devices using the terminal emulator program provided in the distribution of {\ttfamily Tiny\+OS}.

Note that this function will block until the terminal emulators are executed.


\begin{DoxyParams}{Parameters}
{\em vmc} & the configuration to initialize \\
\hline
{\em bootfunc} & the boot function to execute on cores \\
\hline
{\em cores} & the number of cores \\
\hline
{\em serialno} & the number of serial devices \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{bios_8h_a37f8796b7357cdfedc482c0b05c6a115}\label{bios_8h_a37f8796b7357cdfedc482c0b05c6a115}} 
\index{bios.h@{bios.h}!vm\_run@{vm\_run}}
\index{vm\_run@{vm\_run}!bios.h@{bios.h}}
\doxysubsubsection{\texorpdfstring{vm\_run()}{vm\_run()}}
{\footnotesize\ttfamily void vm\+\_\+run (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structvm__config}{vm\+\_\+config}} $\ast$}]{vmc }\end{DoxyParamCaption})}



Boot a Virtual Machine with the given configuration. 

This function sets up a virtual machine (VM) according to the given configuration.

The VM boots by executing the function specified by the {\ttfamily bootfunc} field of the configuration on each core of the simulated VM.

The execution of the VM ends (and this function returns) when (and if) all cores return from bootfunc, in which case the VM shuts down.

If the configuration passed contains illegal values, this function will print an error message and will {\ttfamily abort()}.


\begin{DoxyParams}{Parameters}
{\em vmc} & the configuration of the virtual machine \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{structvm__config}{vm\+\_\+config}} 
\end{DoxySeeAlso}
